
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles.
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Master's Thesis} %TODO: Please add

%\titlerunning{Dummy short title} %TODO: optional, please use if title is longer than one line

\author{V.R. Sathiyanarayana}{Chennai Mathematical Institute, India \and \url{http://sathiyavrs.netlify.app}}{sathiyanarayana@cmi.ac.in}{}{}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

%\author{Joan R. Public\footnote{Optional footnote, e.g. to mark corresponding author}}{Department of Informatics, Dummy College, [optional: Address], Country}{joanrpublic@dummycollege.org}{[orcid]}{[funding]}

\authorrunning{V.R. Sathiyanarayana} % mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Jane Open Access and Joan R. Public} %TODO: mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/ % TODO: Fill something here

\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10003790.10003793</concept_id>
<concept_desc>Theory of computation~Modal and temporal logics</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Modal and temporal logics}

%\ccsdesc[100]{\textcolor{red}{Replace ccsdesc macro with valid one}} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm

\keywords{Logic, Modal and temporal logic} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{I want to thank my advisors Dr. Paul Gastin and Dr. Aiswarya Cyriac for helping me through this project}%optional

\nolinenumbers %uncomment to disable line numbering

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
My master's thesis!
\end{abstract}

\section{Introduction}
\label{sec:introduction}

The separation property, invented by Dov Gabbay, is a strangely influential consequence of the design of popular temporal languages. Simply put, it requires all formulas in the language to be equivalent to a variant made up of formulas purely concerned with one \textit{region} of the flow of time. Surprisingly, this property is linked to expressive completeness: a sufficiently expressive temporal language with the separation property can express any first-order property. In the next few sections, we will detail the separation property over linear time, its consequences on functional completeness, and discuss the generalization described in \cite{gabbay1994}.

%\paragraph*{Mandatory metadata macros}
\section{Preliminaries}

Before discussing separation, we define some standard notions. A flow of time is simply a non-empty set $T$ partially ordered by the binary relation $<$. We symbolically refer to these flows by the pair $(T, <)$. Examples include $(\mathbb{N}, <)$ and $(\mathbb{R}, <)$ with their natural ordering, unordered trees with the descendant relation, and Mazurkiewicz traces. We will consider the truth values of propositions (from a fixed set $\mathcal{P}$) at points on these flows.

The first-order vocabulary over these structures contains the ordering relation $<$ and a collection of \textit{monadic} relations $Q_1, Q_2, \cdots$ that match the propositions $q_1, q_2, \cdots$ in $\mathcal{P}$. An assignment $h$ of atoms in a time flow $(T, <)$ assigns to each $Q_i$ a subset of $T$ where the atom $q_i$ is true. Augmented with the assignment, the triplet $(T, <, h)$ is called a \textit{temporal structure}. First-order formulas are evaluated over these structures in the usual way. In this discussion, we pay special attention to first-order formulas with a single free-variable; they quite naturally mirror temporal formulas.

Instead of free variables and quantification, temporal languages employ \textit{connectives} to reason through time. Popular connectives include $F$, $P$, $G$, $H$, $U$, and $S$, known as \textit{future}, \textit{past}, \textit{globally}, \textit{history}, \textit{until} and \textit{since} respectively. In this paper, we will limit our discussion to connectives that are definable by monadic first-order formulas.

Temporal formulas are evaluated at points in time. In a temporal structure $\mathcal{M} = (T, <, h)$, atoms are evaluated as
\begin{equation*}
    \mathcal{M}, t \vDash p \Longleftrightarrow (T, <, h[x \mapsto t]) \vDash p(x) \Longleftrightarrow t \in h(p)\\
\end{equation*}
As per the standard notation, the assignment $h[x \mapsto t]$ assigns the time point $t$ to the first-order variable $x$. For a generic connective $\sharp$ of arity $n$, let $\varphi_\sharp(t, X_1, \cdots X_n)$ be the monadic first-order formula defining it. Here, $t$ is the point in time that the connective is evaluated at, and the $X_i$ are monadic (second-order) variables. These variables expect a single-variable first-order formula, as shown below
\begin{equation*}
    \mathcal{M}, t \vDash \sharp(A_1, \cdots A_n) \Longleftrightarrow (T, <, h[x \mapsto t]) \vDash \varphi_\sharp(x, \alpha_{A_1}, \cdots \alpha_{A_n})
\end{equation*}
Here, $A_i$ are temporal formulas and $\alpha_{A_i}$ are their first-order translations. Notably, $\varphi_\sharp$ can only quantify over elements in the domain $T$; it cannot use second order quantifiers.

We illustrate this behaviour with an example. The connective $F$ is defined by the formula
\begin{equation*}
    \varphi_F(t, X) \triangleq \exists x.\, (t < x) \land X(x)
\end{equation*}
Hence, we have
\begin{equation*}
    \mathcal{M}, t \vDash F p \Longleftrightarrow (T, <, h[x \mapsto t]) \vDash \exists y.\, (x < y) \land p(y)
\end{equation*}
We similarly define the other main connectives
\begin{equation*}
    \begin{aligned}
        \varphi_P(t, X) &\triangleq \exists x.\, (x < t) \land X(x)\\
        \varphi_G(t, X) &\triangleq \forall x.\, (t < x) \land X(x)\\
        \varphi_H(t, X) &\triangleq \forall x.\, (x < t) \land X(x)\\
        \varphi_U(t, X_1, X_2) &\triangleq \exists x.\, \left[ \left( t < x \right) \land X_1(x) \land \forall y \left( \left( t < y < x \right) \to X_2(y) \right) \right]\\
        \varphi_S(t, X_1, X_2) &\triangleq \exists x.\, \left[ \left( x < t \right) \land X_1(x) \land \forall y \left( \left( x < y < t \right) \to X_2(y) \right) \right]\\
    \end{aligned}
\end{equation*}
Note that, unlike the typical definition of $U$, $\varphi_U$ doesnâ€™t rely on the present point $t$. Such an until is referred to in the literature by either the \textit{strict} until (see \cite{gastinStrictUntil06}) or the \textit{strong} until (see \cite{BeCl16}). This particular behaviour makes observing separation much easier.

\begin{definition}[Expressive Completeness]
    \label{expressive-completeness-definition}
    A temporal language is \textbf{first-order expressively complete} over a class of time flows \textit{iff} there exists a temporal formula $A$ for any first-order formula with one free variable $\varphi(t)$ such that
\begin{equation*}
    \mathcal{M}, t \vDash A \Longleftrightarrow \mathcal{M}[x \mapsto t] \vDash \varphi(x)
\end{equation*}
    for any flow $\mathcal{M}$ in the class.
\end{definition}
On a related note, a flow of time $(T, <)$ is termed to be expressively complete if there exists an expressively complete temporal language over it.

\section{Linear Flows}

In \cite{gabbay1994}, Gabbay showed how the temporal language $\mathbf{L}$ with the strict until $U$ and since $S$ connectives satisfies the separation property over the integer time flow $(\mathbb{Z}, <)$.

To discuss this further, we need the notion of \textit{regions} and \textit{pure formulas}. Informally, the flow of time $(T, <)$ is partitioned into a set of regions. The positions of these regions depends on the position of the time point $t$ where the temporal formula is being evaluated. For linear flows, Gabbay selected three regions:
\begin{itemize}
    \item The \textit{past} of $t$, formally defined as $\{ x \mid x \in \mathbb{Z} \land x < t\}$.
    \item The \textit{present}, which is simply $\{ t \}$.
    \item The \textit{future} of $t$, which naturally is $\{x \mid x \in \mathbb{Z} \land t < x\}$
\end{itemize}
Note that these regions are disjoint, and that the union of these regions produces the entire flow. Also, notice that these regions are first-order definable.

% TODO: Consider writing these in \begin{definition}
Now, we define \textit{pure formulas}. For any flow $(T, <)$, we denote two assignments $h$ and $h'$ to be in \textit{agreement} over a region $R \subset T$ \textit{iff} for any atom $q \in \mathcal{P}$ and any point $s \in R$,
\begin{equation*}
    s \in h(q) \Longleftrightarrow s \in h'(q)
\end{equation*}
Now, call a temporal formula $A$ \textit{pure} with respect to a region $R$ \textit{iff} for any two assignments $h$ and $h'$ that agree on $R$,
\begin{equation*}
    (T, <, h), t \vDash A \Longleftrightarrow (T, <, h'), t \vDash A
\end{equation*}
In other words, $A$ is true on $h'$ \textit{iff} $A$ is true on $h$. We use the terms \textit{pure past}, \textit{pure present}, or \textit{pure future} to denote pure formulas in the past, present, and future regions respectively.

Finally, call a formula $A$ \textbf{separated} if it is a Boolean combination of pure formulas. Now, we can state the separation property
\begin{theorem}[Separation Theorem]
    \label{separation-theorem-linear-time}
    Every temporal formula $A$ in the language of $S$ and $U$ over linear time can be equivalently represented by a separated formula.
\end{theorem}

The proof of this theorem is quite involved, and is presented in full detail in \cite{gabbay1994}. In the next few sections, I'll give a high-level overview of Gabbay et. al.'s scheme. To mirror their notation, I'll write $U$ formulas as $U(p, q)$ instead of $q \,\mathcal{U}\, p$.

\subsection{Separating $S$ and $U$ over linear time}

As a reminder, we restate the definitions of $U$ and $S$
\begin{equation*}
    \begin{aligned}
        \mathcal{M}, t \vDash U(p, q) &\Longleftrightarrow \mathcal{M}, t \vDash \exists x.\, (t < x) \land p(x) \land \forall y \left( t < y < x \to q\left( y \right) \right)\\
        \mathcal{M}, t \vDash S(p, q) &\Longleftrightarrow \mathcal{M}, t \vDash \exists x.\, (x < t) \land p(x) \land \forall y \left( x < y < t \to q\left( y \right) \right)
    \end{aligned}
\end{equation*}
For convenience, we refer to the left condition ($p$) in $U(p, q)$ as the \textit{target} condition and the right condition ($q$) as the \textit{path} condition. Observe that, over linear time, a formula composed only of $U$s is a pure future formula, a formula composed of $S$s is a pure past formula. The task, therefore, is to transform formulas with both $U$s and $S$es.

Over the integer time flow $(\mathbb{Z}, <)$, these connectives naturally possess the following properties
\begin{equation}
    \label{eq:or-and-S-U}
    \begin{aligned}
        U(\alpha \lor \beta, \gamma) &\equiv U(\alpha, \gamma) \lor U(\beta, \gamma)\\
        U(\alpha, \beta \land \gamma) &\equiv U(\alpha, \beta) \land U(\alpha, \gamma)
    \end{aligned}
\end{equation}
In addition, their negations can be usefully rewritten as
\begin{equation*}
    \begin{aligned}
        \lnot U(\alpha, \beta) &\equiv G(\lnot \alpha) \lor U(\lnot \alpha \land \lnot \beta, \lnot \alpha) \\
        \lnot S(\alpha, \beta) &\equiv H(\lnot \alpha) \lor S(\lnot \alpha \land \lnot \beta, \lnot \alpha)
    \end{aligned}
\end{equation*}
where the semantics of $G$ and $H$ are
\begin{equation*}
    \begin{aligned}
        \mathcal{M}, t \vDash G(\alpha) &\Longleftrightarrow \mathcal{M}, t \vDash \forall t'.\; t' > t \to \varphi_\alpha(t') \\
        \mathcal{M}, t \vDash H(\alpha) &\Longleftrightarrow \mathcal{M}, t \vDash \forall t'.\; t' < t \to \varphi_\alpha(t')
    \end{aligned}
\end{equation*}
Here, $\varphi_\alpha$ is the first-order translation of $\alpha$.

Our strategy involves \textit{pulling-out} $U$s from inside $S$ and vice versa. We accomplish this by writing all temporal formulas in a standard notation, and then applying a sequence of \textit{elimination} rules. In the next section, we describe these rules.

\subsubsection{Eliminations}
\label{sec:eliminations-linear}

Let $\alpha$, $\beta$, $\varphi$ and $\psi$ be boolean combinations of propositional atoms. In the following subsections, we pull out a $U(\varphi, \psi)$ from inside a $S$ under a variety of minimal configurations. In later sections, we show that these configurations suffice.

\paragraph*{$S(\alpha \land U(\varphi, \psi), \beta)$}
This formula requires $U(\varphi, \psi)$ to be true at a point $t'$ in the past of $t$. This in turn implies $\varphi$ at some point $t''$ ahead of $t'$. This naturally breaks down into three cases: $t'' > t$, $t'' = t$, and $t' < t'' < t$. The translation is
\begin{equation*}
    \begin{aligned}
        &S(\varphi \land \beta \land S(\alpha, \psi \land \beta), \beta)\\
        \lor \quad &\left(S(\alpha, \psi \land \beta) \land \left(\varphi \lor \left(\psi \land U(\varphi, \psi) \right) \right) \right)
    \end{aligned}
\end{equation*}

\paragraph*{$S(\alpha \land \lnot U(\varphi, \psi), \beta)$}
In this case, we immediately rewrite $\lnot U(\varphi, \psi)$ as $G(\lnot \alpha) \lor U(\lnot \alpha \land \lnot \beta, \lnot \alpha)$. This gives us
\begin{equation*}
    \begin{aligned}
        S(\alpha \land \lnot &U(\varphi, \psi), \beta) \equiv\\
        &S(\alpha \land G(\lnot \varphi), \beta) \\
        \lor \quad &S(\alpha \land U(\lnot \varphi \land \lnot \psi, \lnot \varphi), \beta)
    \end{aligned}
\end{equation*}
where each individual case can be translated using the ideas used to rewrite $S(\alpha \land U(\varphi, \psi), \beta)$.

\paragraph*{$S(\alpha, U(\varphi, \psi))$}
It's instructive to recognize how $S(\alpha, U(\varphi, \psi))$ could be translated. Unlike the previous cases, the Until fragment needs to be true at each point in the path to $\alpha$. This could involve multiple segments in this path where $\psi$ is true till $\varphi$ is true. Wonderfully, this is \textit{indistinguishable} from the case where, at each point in the path, either $\varphi$ or $\psi$ is true. This formula is translated to % TODO: Fix this formula
\begin{equation*}
    \begin{aligned}
        &S(\alpha, \bot) \\
        \lor \quad &S(\alpha, \varphi \lor \psi) \land \left[ \varphi \lor \left(\psi \land U\left(\varphi, \psi \right) \right) \right] \\
    \end{aligned}
\end{equation*}
Here, $S(\alpha, \bot)$ can only be true if $\alpha$ is true at the previous point. Otherwise, we'll need $U(\varphi, \psi)$ to be satisfied at the previous location, hence the $\varphi \lor (\psi \land U(\varphi, \psi))$ at the present. At each point $t'$ in the path to $\alpha$, if $t' + 1 \vDash \varphi$, $t' \vDash U(\varphi, \psi)$. Otherwise, $t' + 1 \vDash \psi$. At this point, we can use an inductive argument, starting from the previous point, to prove the correctness of this translation.

\paragraph*{$S(\alpha, \beta \lor U(\varphi, \psi))$}

% I had some trouble extending this analysis to translate $S(\alpha, \beta \lor U(\varphi, \psi))$. Gabbay's presentation is confusing, as he provides an unnecessarily complicated translation for this, but later presents a cleverer translation embedded in his translation of $S(\alpha \land U(\varphi, \psi), \beta \lor U(\varphi, \psi))$, a more complex formula. Gratifyingly, this translation uses elements of my translation of $S(\alpha, U(\varphi, \psi))$.

The idea is to attempt to enforce $U(\varphi, \psi)$ at each point in the path \textit{iff} we can detect an earlier point in the path which needed to satisfy it. A simple way to detect these points is to look for the moment where $\lnot \beta$ was true, and check whether, along the way to that point, $\lnot \varphi$ was true at each step. Accordingly, $S(\lnot \beta \land \lnot \alpha, \lnot \varphi \land \lnot \alpha)$ does the trick. Here, the $\lnot \alpha$ is to ensure that we specifically look for points in the future of $\alpha$, the leftmost point in our consideration.

It's important to recognize that we are capable of recognizing such points at each step of the path to $\alpha$. This means that, if we recognized such a point that's 3 steps away, we recognized it at 2 and 1 step away too. This allows us a simple fix: $S(\lnot \beta, \lnot \varphi \land \lnot \alpha) \to \varphi \lor \psi$. If $\varphi$ was true, we will not see this point in our next search. Otherwise, $\psi$ would be true, allowing for the possibility of enforcement in the future.

The overall translation now is
\begin{equation*}
    \begin{aligned}
    S(\alpha, \lnot \alpha \land (S(\lnot \beta \land \lnot \alpha, \lnot \varphi \land \lnot \alpha) \to \varphi \lor \psi)) \\
    \quad \land \quad S(\lnot \beta \land \lnot \alpha, \lnot \varphi \land \lnot \alpha) \to (\varphi \lor (\psi \land U(\varphi, \psi)))
    \end{aligned}
\end{equation*}

\paragraph*{$S(\alpha, \beta \lor \lnot U(\varphi, \psi))$}
This case is very similar to the previous case. The points we search for must be in danger of satisfying $U(\varphi, \psi)$; hence, we look for $S(\lnot \beta \land \lnot \alpha, \psi \land \lnot \alpha)$. We fix these points by requiring $\varphi$ to be false. In the worst-case, we've dragged on the possible \textit{until} to the present, at which point we can extinguish all hope. This gives us the overall translation:
\begin{equation*}
    \begin{aligned}
    S(\alpha, \lnot \alpha \land (S(\lnot \beta \land \lnot \alpha, \psi \land \lnot \alpha) \to \not \varphi)) \\
    \quad \land \quad S(\lnot \beta \land \lnot \alpha, \psi \land \lnot \alpha) \to ((\lnot \psi \land \lnot \varphi) \lor (\lnot U(\varphi, \psi)))
    \end{aligned}
\end{equation*}

\paragraph*{$S(\alpha \land U(\varphi,\psi), \beta \lor U(\varphi, \psi))$}
This is a neat combination of $S(\alpha \land U(\varphi, \psi), \beta)$ and $S(\alpha, \beta \lor U(\varphi, \psi))$. The translation is simple. \textit{I believe Gabbay made a typo in this particular example. \cite{xpathComplete} mentions this.}
\begin{equation*}
    \begin{aligned}
        \quad S(\alpha, \psi) \land (\varphi \lor (\psi \land U(\varphi, \psi))) \\
        \lor \quad \quad S(\varphi \land S(\alpha, \psi), S(\lnot \beta, \lnot \varphi) \to \varphi \lor \psi)\\
        \quad \land \quad S(\lnot \beta, \lnot \varphi) \to (\varphi \lor (\psi \land U(\varphi, \psi)))
    \end{aligned}
\end{equation*}

\subsubsection{Putting it all together}

The eliminations presented in the previous section lend credence to the idea of separation. Amazingly, Gabbay presents a neat induction scheme that builds on these rules to separate \textit{any} temporal formula in the language. In this section, we present an overview of his arguments (presented in more detail in \cite{gabbay1994}).

\begin{lemma}
\label{lemma:separation-linear-step1}
    Let $\varphi$ and $\psi$ be pure-present formulas and $\alpha$ and $\beta$ be formulas such that the only appearance of a $U$ in either of them is $U(\varphi, \psi)$, and that $U$ isn't nested inside a $S$. Then $S(\alpha, \beta)$ can be written as a syntactically separated formula where the only appearance of $U$ is $U(\varphi, \psi)$.
\end{lemma}
\begin{proof}
    We start by writing $\alpha$ and $\beta$ in their conjunctive and disjunctive normal forms respectively. During this transformation, we treat all top-level instances of $U$ and $S$ in them as atomic propositions. This gives us
    \begin{equation*}
        \begin{aligned}
            \alpha &\equiv \bigvee_i \left( \alpha_{i, 1} \land \alpha_{i, 2} \land \cdots \land \alpha_{i, m_i} \right)\\
            \beta &\equiv \bigwedge_j \left( \beta_{j, 1} \lor \beta_{j, 2} \lor \cdots \lor \beta_{j, n_j} \right)
        \end{aligned}
    \end{equation*}
    Here, the literals $\alpha_{i, k}$ and $\beta_{i, k}$ are composed of propositional atoms, $S$ formulas, and $U(\varphi, \psi)$. We use the above and equation \eqref{eq:or-and-S-U} to write $S(\alpha, \beta)$ as
    \begin{equation*}
        \begin{aligned}
            S(\alpha, \beta) &\longmapsto S\left(\bigvee_i (\alpha_{i, 1} \land \cdots \land \alpha_{i, m_i}), \beta\right)\\
            &\longmapsto \bigvee_i S(\alpha_{i, 1} \land \cdots \land \alpha_{i, m_i}, \beta)\\
            &\longmapsto \bigvee_i S\left(\alpha_{i, 1} \land \cdots \land \alpha_{i, m_i}, \bigwedge_j \left( \beta_{j, 1} \lor \cdots \lor \beta_{j, n_i} \right) \right)\\
            &\longmapsto \bigvee_i \bigwedge_j S\left(\alpha_{i, 1} \land \cdots \land \alpha_{i, m_i}, \beta_{j, 1} \lor \cdots \lor \beta_{j, n_i} \right)
        \end{aligned}
    \end{equation*}
    In the resulting formula, the target of each top-level $S$ is a conjunction of literals, and the path condition is a disjunction of literals. Notably, if $U(\varphi, \psi)$ doesn't appear in the target and the path of a top-level $S$ formula, that subformula is a pure-past formula.

    Hence, we focus our attention on the top-level $S$ formulas containing $U(\varphi, \psi)$. In one such formula, let $\alpha'$ be the conjunction of all literals in the target that aren't $U(\varphi, \psi)$ or its negation. Similarly, let $\beta'$ be the disjunction of all literals in the path that aren't $U(\varphi, \psi)$ or its negation. This lets us write that formula as one of the following
    \begin{equation*}
        \begin{aligned}
            &S(\alpha' \land \pm U(\varphi, \psi), \beta')\\
            &S(\alpha', \beta' \lor \pm U(\varphi, \psi))\\
            &S(\alpha' \land \pm U(\varphi, \psi), \beta' \lor \pm U(\varphi, \psi))\\
        \end{aligned}
    \end{equation*}
    Clearly, the eliminations we explored in the previous section can separate this formula! Additionally, note that the only $U$ formula in the RHS of the eliminations is $U(\varphi, \psi)$, satisfying the condition specified in the beginning of the lemma.

    Applying these elimination rules to each top-level $S$ containing a $U(\varphi, \psi)$ produces a separated formula equivalent to $S(\varphi, \psi)$. This completes the proof.
\end{proof}

The second step of the induction scheme is to consider cases where $U(\varphi, \psi)$ is nested under multiple levels of $S$.
\begin{lemma}
\label{lemma:separation-linear-step2}
    Let $\varphi$ and $\psi$ be pure-present formulas, and let $\gamma$ be a formula such that the only appearance of a $U$ in $\alpha$ is $U(\varphi, \psi)$. Then, $\gamma$ can be written as a syntactically separated formula where the only appearance of a $U$ is $U(\varphi, \psi)$.
\end{lemma}
\begin{proof}
    We show this lemma by inducting on the pair $(n_1, n_2)$, where $n_1$ is the maximum number of nested $S$es above a $U(\varphi, \psi)$ and $n_2$ is the number of $U(\varphi, \psi)$ nested inside $n_1$ $S$s.
    \begin{description}
        \item[Base case.] Here, $n_1 = 0$, and $\gamma$ is already separated.
        \item[Induction step.] Pick the most deeply nested subformula $S(\alpha, \beta)$ of $\gamma$ such that all instances of $U(\varphi, \psi)$ in $\alpha$ and $\beta$ are not nested inside a $S$. Applying lemma \ref{lemma:separation-linear-step1} to $S(\alpha, \beta)$ strictly reduces $(n_1, n_2)$, allowing us to use the induction hypothesis. Remember, lemma \ref{lemma:separation-linear-step1} only generates formulas where then only appearance of $U$ is $U(\varphi, \psi)$, which is required to use the induction hypothesis.
    \end{description}
    This completes the proof.
\end{proof}
The next step generalizes this approach to different (basic) until subformulas.
\begin{lemma}
\label{lemma:separation-linear-step3}
    Let $\varphi_1, \varphi_2, \ldots \varphi_n$ and $\psi_1, \psi_2, \ldots \psi_n$ be pure present formulas and $\gamma$ be a formula such that all appearances of $U$ in $\gamma$ are of the form $U(\varphi_i, \psi_i)$ for some $i \in \{1, 2, \ldots n\}$. Then, $\gamma$ can be written as a syntactically separated formula.
\end{lemma}
\begin{proof}
    Predictably, we induct on $n$.
    \begin{description}
        \item[Base case.] This is $n = 1$, identical to lemma \ref{lemma:separation-linear-step2}.
        \item[Induction case.] Introduce new propositional atoms $p_1, p_2, \ldots p_{n-1}$. For each $i \in \{1, \ldots n - 1\}$, replace each occurrence of $U(\varphi_i, \psi_i)$ in $\gamma$ with $p_i$ to produce $\gamma'$. We can apply lemma \ref{lemma:separation-linear-step2} to $\gamma'$ to produce its separated equivalent, $\gamma''$. Replace each instance of $p_i$ in $\gamma''$ with $U(\varphi_i, \psi_i)$ to produce $\gamma'''$. Finally, apply the induction hypothesis on $\gamma'''$ to separate $\gamma$.
    \end{description}
    This proves the lemma.
    \begin{remark*}
        It isn't difficult to see that we cannot use lemma \ref{lemma:separation-linear-step2} if we introduce a single atom $p_n$ to represent $U(\varphi_n, \psi_n)$. Introducing more atoms is essential to the overall induction structure.
    \end{remark*}
\end{proof}
We can now finally consider the case of nested $U$s.
\begin{lemma}
    \label{lemma:separation-linear-step4}
    Let $\gamma$ be a formula that doesn't contain $S$s nested inside a $U$. Then, $\gamma$ can be separated.
\end{lemma}
\begin{proof}
    We cleverly induct on the maximum nesting depths of $U$s under a $S$. Let $n$ be the maximum $U$-nesting depth of $\gamma$.
    \begin{description}
        \item[Base case.] This is $n = 1$, which is lemma \ref{lemma:separation-linear-step3}.
        \item[Induction step.] Suppose there are $m$ subformulas rooted at a $U$ that aren't under a $U$ and are under an $S$. Introduce $2m$ atoms $\{p_1, \ldots p_{2m}\}$ and replace the target and path conditions of these $m$ subformulas with these atoms. This produces a new formula $\gamma'$ that is amenable to lemma \ref{lemma:separation-linear-step3}. Applying the lemma produces a separated formula $\gamma''$ that uses the atoms $\{p_1, \ldots p_{2m}\}$. These atoms may appear under a $S$ in the separated formula $\gamma''$. Now, replace each of these atoms by the target/path condition they substituted earlier. This produces $\gamma'''$, a formula with the maximum $U$-nesting depth under a $S$ strictly $< n$. Applying the induction hypothesis on $\gamma'''$ proves this lemma.
    \end{description}
    \begin{remark*}
        We don't need to consider the value $m$ in our induction hypothesis, as required in the proof of lemma \ref{lemma:separation-linear-step2}.
    \end{remark*}
\end{proof}
Before we finally prove the separation theorem, notice that, since $U$ and $S$ are duals of each other, the eliminations in section \ref{sec:eliminations-linear} and lemmas \ref{lemma:separation-linear-step1}, \ref{lemma:separation-linear-step2}, \ref{lemma:separation-linear-step3} and \ref{lemma:separation-linear-step4} hold when the $U$ and $S$ are swapped.
\begin{theorem}[Separation Theorem]
    \label{theorem:separation-linear-final}
    Any formula $\gamma$ that uses $S$ and $U$ can be separated.
\end{theorem}
\begin{proof}
    We induct over the \textit{junction depth} of the input formula. Define this depth as follows.
    \begin{definition}[Junction Depth]
        The junction depth of a temporal formula $\gamma$ is the length of the longest sequence of subformulas $\alpha_1, \alpha_2, \ldots \alpha_n$ of $\gamma$ such that
        \begin{enumerate}
            \item The root of all $\alpha_i$ is either a $U$ or a $S$.
            \item $\alpha_{i+1}$ is a subformula of $\alpha_i$.
            \item If $\alpha_i$ is rooted by a $U$ (or a $S$), then $\alpha_{i+1}$ is rooted by a $S$ (or a $U$, respectively).
            \item There is no subformula $\beta$ of $\gamma$ such that \label{item:junction-depth-extra-condition}
                \begin{enumerate}
                    \item $\beta$ is a strict subformula of $\alpha_i$.
                    \item $\alpha_{i+1}$ is a strict subformula of $\beta$.
                    \item $\beta$ and $\alpha_{i+1}$ are rooted by the same connective.
                \end{enumerate}
        \end{enumerate}
    \end{definition}
    Note that condition \ref{item:junction-depth-extra-condition} isn't necessary to compute the junction depth. However, I will use it in my proof.

    As an illustration, observe that the junction depth of the formula $U \left(a, S\left( U(c, d), U(e, f) \right) \right)$ is 3, and there are two possible sequences:
    \begin{itemize}
        \item $U \left(a, S\left( U(c, d), U(e, f) \right) \right), S(U(c, d), U(e, f)), U(c, d)$.
        \item $U \left(a, S\left( U(c, d), U(e, f) \right) \right), S(U(c, d), U(e, f)), U(e, f)$.
    \end{itemize}

    Let the junction depth of $\gamma$ be $n$.
    \begin{description}
        \item[Base case 1: $n = 1$.] The formula is already separated.
        \item[Base case 2: $n = 2$.] In this case, apply lemma \ref{lemma:separation-linear-step4} to separate $\gamma$.
        \item[Induction step: $n \geq 3$.] Let there be $m$ sequences of subformulas that witness the junction depth $n$. Form a set $A$ of all subformulas at position 3 of these $m$ sequences; the size of $A$ can be less than $m$. Note that condition \ref{item:junction-depth-extra-condition} makes these subformulas maximal; i.e., no formula in $A$ is a subformula of another. This maximality allows us to substitute each formula in $A$ with a newly introduced atom from the set $\{p_1, \ldots p_{|A|}\}$.

        Call the resulting formula $\gamma'$. It isn't difficult to argue that this formula has a junction depth of strictly $< n$, allowing us to apply the induction hypothesis. This produces a separated formula $\gamma''$ with $|A|$ new atoms. Substitute the subformulas in $A$ at the corresponding atoms in $\gamma''$ to produce $\gamma'''$.

        Now, all subformulas in $A$ have a junction depth of $n - 2$. If all of these appear in the pure-present segment of $\gamma''$, the new junction depth of $\gamma'''$ grows to at-most $n - 2$. Similarly, if one of these substitutions occurs inside a pure-past / pure-future segment of $\gamma''$, the junction depth grows to at-most $n - 1$. This allows us to apply the induction hypothesis again, producing the fully separated formula $\gamma'''$.
    \end{description}
    This proves the separation theorem over linear time.
\end{proof}

%%
%% Bibliography
%%

%% Please use bibtex,

\bibliography{refs}

% \appendix
\end{document}

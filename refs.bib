@article{DBLP:journals/cacm/Knuth74,
  author    = {Donald E. Knuth},
  title     = {{Computer Programming as an Art}},
  journal   = {Commun. {ACM}},
  volume    = {17},
  number    = {12},
  pages     = {667--673},
  year      = {1974},
  doi       = {10.1145/361604.361612},
  timestamp = {Tue, 07 Jun 2011 16:50:57 +0200},
  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/cacm/Knuth74},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@article{DBLP:journals/cacm/Dijkstra68a,
  author    = {Edsger W. Dijkstra},
  title     = {Letters to the editor: go to statement considered harmful},
  journal   = {Commun. {ACM}},
  volume    = {11},
  number    = {3},
  pages     = {147--148},
  year      = {1968},
  doi       = {10.1145/362929.362947},
  timestamp = {Thu, 09 Feb 2006 13:19:49 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/cacm/Dijkstra68a},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@book{DBLP:books/mk/GrayR93,
  author    = {Jim Gray and
               Andreas Reuter},
  title     = {Transaction Processing: Concepts and Techniques},
  publisher = {Morgan Kaufmann},
  year      = {1993},
  isbn      = {1-55860-190-2},
  timestamp = {Thu, 05 Nov 2015 19:53:28 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/books/mk/GrayR93},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}



@inproceedings{DBLP:conf/focs/HopcroftPV75,
  author    = {{John E.} Hopcroft and
               {Wolfgang J.} Paul and
               {Leslie G.} Valiant},
  title     = {On Time versus Space and Related Problems},
  booktitle = {16th Annual Symposium on Foundations of Computer Science, Berkeley,
               California, USA, October 13-15, 1975},
  pages     = {57--64},
  year      = {1975},
  crossref  = {DBLP:conf/focs/FOCS16},
  doi       = {10.1109/SFCS.1975.23},
  timestamp = {Tue, 16 Dec 2014 09:57:24 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/conf/focs/HopcroftPV75},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@proceedings{DBLP:conf/focs/FOCS16,
  title     = {16th Annual Symposium on Foundations of Computer Science, Berkeley,
               California, USA, October 13-15, 1975},
  publisher = {{IEEE} Computer Society},
  year      = {1975},
  timestamp = {Mon, 15 Dec 2014 18:48:44 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/conf/focs/FOCS16},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}


@book{gabbay1994,
  author = {Gabbay, Dov M. and Hodkinson, Ian and Reynolds, Mark},
  title = {Temporal Logic (Vol. 1): Mathematical Foundations and Computational Aspects},
  year = {1994},
  isbn = {0198537697},
  publisher = {Oxford University Press, Inc.},
  address = {USA}
}
@article{alur2009,
  author = {Alur, Rajeev and Madhusudan, P.},
  title = {Adding Nesting Structure to Words},
  year = {2009},
  issue_date = {May 2009},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {56},
  number = {3},
  issn = {0004-5411},
  url = {https://doi.org/10.1145/1516512.1516518},
  doi = {10.1145/1516512.1516518},
  abstract = {We propose the model of nested words for representation of data with both a linear ordering and a hierarchically nested matching of items. Examples of data with such dual linear-hierarchical structure include executions of structured programs, annotated linguistic data, and HTML/XML documents. Nested words generalize both words and ordered trees, and allow both word and tree operations. We define nested word automata—finite-state acceptors for nested words, and show that the resulting class of regular languages of nested words has all the appealing theoretical properties that the classical regular word languages enjoys: deterministic nested word automata are as expressive as their nondeterministic counterparts; the class is closed under union, intersection, complementation, concatenation, Kleene-*, prefixes, and language homomorphisms; membership, emptiness, language inclusion, and language equivalence are all decidable; and definability in monadic second order logic corresponds exactly to finite-state recognizability. We also consider regular languages of infinite nested words and show that the closure properties, MSO-characterization, and decidability of decision problems carry over.The linear encodings of nested words give the class of visibly pushdown languages of words, and this class lies between balanced languages and deterministic context-free languages. We argue that for algorithmic verification of structured programs, instead of viewing the program as a context-free language over words, one should view it as a regular language of nested words (or equivalently, a visibly pushdown language), and this would allow model checking of many properties (such as stack inspection, pre-post conditions) that are not expressible in existing specification logics.We also study the relationship between ordered trees and nested words, and the corresponding automata: while the analysis complexity of nested word automata is the same as that of classical tree automata, they combine both bottom-up and top-down traversals, and enjoy expressiveness and succinctness benefits over tree automata.},
  journal = {J. ACM},
  month = {may},
  articleno = {16},
  numpages = {43},
  keywords = {tree automata, Pushdown automata, XML processing, software model checking}
}
@article{nwtl,
  TITLE = {{First-Order and Temporal Logics for Nested Words}},
  AUTHOR = {Rajeev Alur and Marcelo Arenas and Pablo Barcelo and Kousha Etessami and Neil Immerman and Leonid Libkin},
  URL = {https://lmcs.episciences.org/782},
  DOI = {10.2168/LMCS-4(4:11)2008},
  JOURNAL = {{Logical Methods in Computer Science}},
  VOLUME = {{Volume 4, Issue 4}},
  YEAR = {2008},
  MONTH = Nov,
  KEYWORDS = {Computer Science - Logic in Computer Science ; F.1.1, F.3.1, F.4.1},
}
@InProceedings{caret,
  author="Alur, Rajeev
  and Etessami, Kousha
  and Madhusudan, P.",
  editor="Jensen, Kurt
  and Podelski, Andreas",
  title="A Temporal Logic of Nested Calls and Returns",
  booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
  year="2004",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="467--481",
  abstract="Model checking of linear temporal logic (LTL) specifications with respect to pushdown systems has been shown to be a useful tool for analysis of programs with potentially recursive procedures. LTL, however, can specify only regular properties, and properties such as correctness of procedures with respect to pre and post conditions, that require matching of calls and returns, are not regular. We introduce a temporal logic of calls and returns (CaRet) for specification and algorithmic verification of correctness requirements of structured programs. The formulas of CaRet  are interpreted over sequences of propositional valuations tagged with special symbols call and ret. Besides the standard global temporal modalities, CaRet  admits the abstract-next operator that allows a path to jump from a call to the matching return. This operator can be used to specify a variety of non-regular properties such as partial and total correctness of program blocks with respect to pre and post conditions. The abstract versions of the other temporal modalities can be used to specify regular properties of local paths within a procedure that skip over calls to other procedures. CaRet  also admits the caller modality that jumps to the most recent pending call, and such caller modalities allow specification of a variety of security properties that involve inspection of the call-stack. Even though verifying context-free properties of pushdown systems is undecidable, we show that model checking CaRet  formulas against a pushdown model is decidable. We present a tableau construction that reduces our model checking problem to the emptiness problem for a B{\"u}chi pushdown system. The complexity of model checking CaRet  formulas is the same as that of checking LTL formulas, namely, polynomial in the model and singly exponential in the size of the specification.",
  isbn="978-3-540-24730-2"
}
@Article{ModelCheckingUsage2018,
  author={Bo{\v{s}}na{\v{c}}ki, Dragan
  and Wijs, Anton},
  title={Model checking: recent improvements and applications},
  journal={International Journal on Software Tools for Technology Transfer},
  year={2018},
  month={Oct},
  day={01},
  volume={20},
  number={5},
  pages={493-497},
  abstract={Model checking (Baier and Katoen in Principles of model checking, MIT Press, Cambridge, 2008; Clarke et al. in Model checking, MIT Press, Cambridge, 2001) is an automatic technique to formally verify that a given specification of a concurrent system meets given functional properties. Its use has been demonstrated many times over the years. Key characteristics that make the method so appealing are its level of automaticity, its ability to determine the absence of errors in the system (contrary to testing techniques) and the fact that it produces counter-examples when errors are detected, that clearly demonstrate not only that an error is present, but also how the error can be produced. The main drawback of model checking is its limited scalability, and for this reason, research on reducing the computational effort has received much attention over the last decades. Besides the verification of qualitative functional properties, the model checking technique can also be applied for other types of analyses, such as planning and the verification of quantitative properties. We briefly discuss several contributions in the model checking field that address both its scalability and its applicability to perform planning and quantitative analysis. In particular, we introduce six papers selected from the 23rd International SPIN Symposium on Model Checking Software (SPIN 2016).},
  issn={1433-2787},
  doi={10.1007/s10009-018-0501-x},
  url={https://doi.org/10.1007/s10009-018-0501-x}
}
@inproceedings{SoftwareModelChecking,
  title={Logics and Automata for Software Model-Checking 1},
  author={Rajeev Alur and Swarat Chaudhuri},
  year={2006}
}
@inproceedings{xpathComplete,
  author = {Marx, Maarten},
  title = {Conditional XPath, the First Order Complete XPath Dialect},
  year = {2004},
  isbn = {158113858X},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1055558.1055562},
  doi = {10.1145/1055558.1055562},
  abstract = {XPath is the W3C -- standard node addressing language for XML documents. XPath is still under development and its technical aspects are intensively studied. What is missing at present is a clear characterization of the expressive power of XPath, be it either semantical or with reference to some well established existing (logical) formalism. Core XPath (the logical core of XPath 1.0 defined by Gottlob et al.) cannot express queries with conditional paths as exemplified by "do a child step, while test is true at the resulting node." In a first-order complete extension of Core XPath, such queries are expressible, We add conditional axis relations to Core XPath and show that the resulting language, called conditional XPath, is equally expressive as first-order logic when interpreted on ordered trees. Both the result, the extended XPath language, and the proof are closely related to temporal logic. Specifically, while Core XPath may be viewed as a simple temporal logic, conditional XPath extends this with (counterparts of) the since and until operators.},
  booktitle = {Proceedings of the Twenty-Third ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems},
  pages = {13–22},
  numpages = {10},
  location = {Paris, France},
  series = {PODS '04}
}
@inproceedings{xpathConditional,
  author = {Marx, Maarten},
  year = {2004},
  month = {04},
  pages = {},
  title = {XPath with Conditional Axis Relations},
  volume = {2992},
  isbn = {978-3-540-21200-3},
  journal = {EDBT},
  doi = {10.1007/978-3-540-24741-8_28}
}
@article{marx2005conditional,
  title={Conditional xpath},
  author={Marx, Maarten},
  journal={ACM Transactions on Database Systems (TODS)},
  volume={30},
  number={4},
  pages={929--959},
  year={2005},
  publisher={ACM New York, NY, USA}
}
@article{BeCl16,
author = {Benedikt, Michael and Ley, Clemens},
title = {Limiting Until in Ordered Tree Query Languages},
year = {2016},
issue_date = {March 2016},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {17},
number = {2},
issn = {1529-3785},
url = {https://doi.org/10.1145/2856104},
doi = {10.1145/2856104},
abstract = {Marx and de Rijke have shown that the navigational core of the w3c XML query language XPath is not first-order complete; that is, it cannot express every query definable in first-order logic over the navigational predicates. How can one extend XPath to get a first-order complete language? Marx has shown that Conditional XPath—an extension of XPath with an “Until” operator—is first-order complete. The completeness argument makes essential use of the presence of upward axes in Conditional XPath. We examine whether it is possible to get “forward-only” languages that are first-order complete for Boolean queries on ordered trees. It is easy to see that a variant of the temporal logic CTL* is first-order complete; the variant has path quantifiers for downward, leftward, and rightward paths, while along a path one can check arbitrary formulas of Linear Temporal Logic (LTL). This language has two major disadvantages: It requires path quantification in both horizontal directions (in particular, it requires looking backward at the prior siblings of a node), and it requires the consideration of formulas of LTL of arbitrary complexity on vertical paths. This last is in contrast with Marx’s Conditional XPath, which requires only the checking of a single Until operator on a path. We investigate whether either of these restrictions can be eliminated. Our main results are negative ones. We show that if we restrict our CTL* language by having an Until operator in only one horizontal direction, then we lose completeness. We also show that no restriction to a “small” subset of LTL along vertical paths is sufficient for first-order completeness. Smallness here means of bounded “Until Depth,” a measure of complexity of LTL formulas defined by Etessami and Wilke. In particular, it follows from our work that Conditional XPath with only forward axes is not expressively complete; this extends results proved by Rabinovich and Maoz in the context of infinite unordered trees.},
journal = {ACM Trans. Comput. Logic},
month = {mar},
articleno = {14},
numpages = {34},
keywords = {xml, temporal logic, Trees, hierarchy}
}
@inproceedings{BeJe07,
author = {Benedikt, Michael and Jeffrey, Alan},
title = {Efficient and Expressive Tree Filters},
year = {2007},
isbn = {3540770496},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {We investigate streaming evaluation of filters on XML documents, evaluated both at the root node and at an arbitrary node. Motivated by applications in protocol processing, we are interested in algorithms that make one pass over the input, using space that is independent of the data and polynomial in the filter. We deal with a logic equivalent to the XPath language, and also an extension with an Until operator. We introduce restricted sublanguages based on looking only at "reversed" axes, and show that these allow polynomial space streaming implementations. We further show that these fragments are expressively complete. Our results make use of techniques developed for the study of Linear Temporal Logic, applied to XML filtering.},
booktitle = {Proceedings of the 27th International Conference on Foundations of Software Technology and Theoretical Computer Science},
pages = {461–472},
numpages = {12},
location = {New Delhi, India},
series = {FSTTCS'07}
}
@book{CounterFreeBook71,
author = {McNaughton, Robert and Papert, Seymour A.},
title = {Counter-Free Automata (M.I.T. Research Monograph No. 65)},
year = {1971},
isbn = {0262130769},
publisher = {The MIT Press}
}
@inproceedings{GabbayBirthday05,
author = {Hodkinson, Ian and Reynolds, Mark},
booktitle={We Will Show Them!},
year = {2005},
month = {01},
pages = {117-142},
title = {Separation - Past, Present, and Future.},
volume = {2}
}
@inproceedings{Gabbay1981,
  title={EXPRESSIVE FUNCTIONAL COMPLETENESS IN TENSE LOGIC},
  author={Dov M. Gabbay},
  year={1981}
}
@article{EtWi00,
author = {Etessami, Kousha and Wilke, Thomas},
year = {2000},
month = {07},
pages = {88-108},
title = {An Until Hierarchy and Other Applications of an Ehrenfeucht–Fraı̈ssé Game for Temporal Logic},
volume = {160},
journal = {Inf. Comput.},
doi = {10.1006/inco.1999.2846}
}
@inproceedings{DiGa08,
  author    = {Volker Diekert and
               Paul Gastin},
  editor    = {J{\"{o}}rg Flum and
               Erich Gr{\"{a}}del and
               Thomas Wilke},
  title     = {First-order definable languages},
  booktitle = {Logic and Automata: History and Perspectives [in Honor of Wolfgang
               Thomas]},
  series    = {Texts in Logic and Games},
  volume    = {2},
  pages     = {261--306},
  publisher = {Amsterdam University Press},
  year      = {2008},
  timestamp = {Wed, 15 Dec 2010 22:16:39 +0100},
  biburl    = {https://dblp.org/rec/conf/birthday/DiekertG08.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@InProceedings{gastinStrictUntil06,
author="Diekert, Volker
and Gastin, Paul",
editor="Farach-Colton, Mart{\'i}n",
title="Pure Future Local Temporal Logics Are Expressively Complete for Mazurkiewicz Traces",
booktitle="LATIN 2004: Theoretical Informatics",
year="2004",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="232--241",
abstract="The paper settles a long standing problem for Mazurkiewicz traces: the pure future local temporal logic defined with the basic modalities exists-next and until is expressively complete. The analogous result with a global interpretation was solved some years ago by Thiagarajan and Walukiewicz (1997) and in its final form without any reference to past tense constants by Diekert and Gastin (2000). Each, the (previously known) global or the (new) local result generalizes Kamp's Theorem for words, because for sequences local and global viewpoints coincide. But traces are labelled partial orders and then the difference between an interpretation globally over cuts (configurations) or locally at points (events) is significant. For global temporal logics the satisfiability problem is non-elementary (Walukiewicz 1998), whereas for local temporal logics both the satisfiability problem and the model checking problem are solvable in Pspace (Gastin and Kuske 2003) as in the case of words. This makes local temporal logics much more attractive.",
isbn="978-3-540-24698-5"
}
@InProceedings{RabinovichUnordered00,
author="Rabinovich, Alexander
and Maoz, Shahar",
editor="Nielsen, Mogens
and Rovan, Branislav",
title="Why so Many Temporal Logics Climb up the Trees?",
booktitle="Mathematical Foundations of Computer Science 2000",
year="2000",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="629--639",
abstract="Many temporal logics were suggested as branching time specification formalisms during the last 20 years. These logics were compared against each other for their expressive power, model checking complexity and succinctness. Yet, unlike the case for linear time logics, no canonical temporal logic of branching time was agreed upon. We offer an explanation for the multiplicity of temporal logics over branching time and provide an objective quantified `yardstick' to measure these logics.",
isbn="978-3-540-44612-5"
}
@article{Amir85,
title = {Separation in nonlinear time models},
journal = {Information and Control},
volume = {66},
number = {3},
pages = {177-203},
year = {1985},
issn = {0019-9958},
doi = {https://doi.org/10.1016/S0019-9958(85)80059-0},
url = {https://www.sciencedirect.com/science/article/pii/S0019995885800590},
author = {Amihood Amir},
abstract = {Little is known about the expressive completeness of connectives in temporal logic systems with a nonlinear time model. We introduce separation—a general tool for proving completeness in nonlinear time models. We then use the separation theorem to show expressive completeness of a finite set of connectives in various branching time models.}
}